"""
Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal.
"""
scalar Address

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
}

type Bundle {
  id: ID!
  bnbPrice: BigDecimal!
}

type Burn {
  id: ID!
  pair: Pair!
  sender: String
  to: String
  liquidity: BigDecimal!
  amount0: BigDecimal
  amount1: BigDecimal
  amountUSD: BigDecimal
  token0: Token!
  token1: Token!
  logIndex: BigInt
  feeTo: String
  feeLiquidity: BigDecimal
  needsComplete: Boolean!
  transaction: Transaction!
  timestamp: BigInt!
}

input Burn_filter {
  pair: ID
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  token0: String
  token1: String
}

enum Burn_orderBy {
  timestamp
}

"""
Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.
An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.
"""
scalar Bytes

"""
Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal.
"""
scalar Bytes32

input FactoryFilter {
  totalPairsGte: BigInt
  totalTransactionsGte: BigInt
}

scalar Hash

"""Long is a 64 bit unsigned integer."""
scalar Long

type Mint {
  id: ID!
  pair: Pair!
  sender: String
  to: String!
  liquidity: BigDecimal!
  amount0: BigDecimal
  amount1: BigDecimal
  amountUSD: BigDecimal
  token0: Token!
  token1: Token!
  feeTo: String
  feeLiquidity: BigDecimal
  logIndex: BigInt
  transaction: Transaction!
  timestamp: BigInt!
}

input Mint_filter {
  pair: ID
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  token0: String
  token1: String
}

enum Mint_orderBy {
  timestamp
}

enum OrderDirection {
  asc
  desc
}

type Pair {
  id: ID!
  block: BigInt!
  name: String!
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!
  reserveBNB: BigDecimal!
  reserveUSD: BigDecimal!
  trackedReserveBNB: BigDecimal!
  token0Price: BigDecimal!
  token1Price: BigDecimal!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  totalTransactions: BigInt!
  timestamp: BigInt!
}

input Pair_filter {
  totalTransactions_gt: BigInt
  token0: String
  token1: String
  token1_in: [String!]
  token0_in: [String!]
  token1_not_in: [String!]
  token0_not_in: [String!]
  id_in: [ID!]
  id: ID
}

enum Pair_orderBy {
  trackedReserveBNB
}

type PairDayData {
  id: ID!
  date: Int!
  pairAddress: Pair!
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!
  reserveUSD: BigDecimal!
  dailyVolumeToken0: BigDecimal!
  dailyVolumeToken1: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyTxns: BigInt!
}

input PairDayData_filter {
  pairAddress: Bytes
  date_gt: Int
  date_lt: Int
  date: Int
  dailyTxns_gt: BigInt
  token1_not_in: [String!]
  token0_not_in: [String!]
  id_in: [ID!]
}

enum PairDayData_orderBy {
  date
  dailyVolumeUSD
}

type PairHourData {
  id: ID!
  hourStartUnix: Int!
  pair: Pair!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!
  reserveUSD: BigDecimal!
  hourlyVolumeToken0: BigDecimal!
  hourlyVolumeToken1: BigDecimal!
  hourlyVolumeUSD: BigDecimal!
  hourlyTxns: BigInt!
}

input PairHourData_filter {
  pair: String
  id_in: [ID!]
  hourStartUnix: Int
  hourStartUnix_gt: Int
  hourStartUnix_lt: Int
}

enum PairHourData_orderBy {
  hourStartUnix
}

type PancakeDayData {
  id: ID!
  date: Int!
  dailyVolumeBNB: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyVolumeUntracked: BigDecimal!
  totalVolumeBNB: BigDecimal!
  totalLiquidityBNB: BigDecimal!
  totalVolumeUSD: BigDecimal!
  totalLiquidityUSD: BigDecimal!
  totalTransactions: BigInt!
}

input PancakeDayData_filter {
  date_gt: Int
  date_lt: Int
  date: Int
}

enum PancakeDayData_orderBy {
  date
}

type PancakeFactory {
  id: ID!
  totalPairs: BigInt!
  totalTransactions: BigInt!
  totalVolumeBNB: BigDecimal!
  totalVolumeUSD: BigDecimal!
  totalLiquidityBNB: BigDecimal!
  totalLiquidityUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
}

type Query {
  pancakeFactory(block: Block_height): PancakeFactory
  pancakeFactories(block: Block_height, skip: Int, first: Int): [PancakeFactory!]!
  bundle(id: ID!, block: Block_height): Bundle
  bundles(block: Block_height): [Bundle!]!
  token(id: ID!, block: Block_height): Token
  tokens(block: Block_height, skip: Int, first: Int, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]!
  pair(id: ID!, block: Block_height): Pair
  pairs(block: Block_height, skip: Int, first: Int, orderBy: Pair_orderBy, orderDirection: OrderDirection, where: Pair_filter): [Pair!]!
  swap(id: ID!, block: Block_height): Swap
  swaps(block: Block_height, skip: Int, first: Int, orderBy: Swap_orderBy, orderDirection: OrderDirection, where: Swap_filter): [Swap!]!
  burn(id: ID!, block: Block_height): Burn
  burns(block: Block_height, skip: Int, first: Int, orderBy: Burn_orderBy, orderDirection: OrderDirection, where: Burn_filter): [Burn!]!
  mint(id: ID!, block: Block_height): Mint
  mints(block: Block_height, skip: Int, first: Int, orderBy: Mint_orderBy, orderDirection: OrderDirection, where: Mint_filter): [Mint!]!
  pancakeDayData(id: ID!, block: Block_height): PancakeDayData
  pancakeDayDatas(block: Block_height, skip: Int = 0, first: Int = 100, orderBy: PancakeDayData_orderBy, orderDirection: OrderDirection, where: PancakeDayData_filter): [PancakeDayData!]!
  pairDayData(id: ID!, block: Block_height): PairDayData
  pairDayDatas(skip: Int = 0, first: Int = 100, orderBy: PairDayData_orderBy, orderDirection: OrderDirection, where: PairDayData_filter, block: Block_height): [PairDayData!]!
  pairHourData(id: ID!, block: Block_height): PairHourData
  pairHourDatas(skip: Int = 0, first: Int = 100, orderBy: PairHourData_orderBy, orderDirection: OrderDirection, where: PairHourData_filter, block: Block_height): [PairHourData!]!
  tokenDayData(id: ID!, block: Block_height): TokenDayData
  tokenDayDatas(skip: Int = 0, first: Int = 100, orderBy: TokenDayData_orderBy, orderDirection: OrderDirection, where: TokenDayData_filter, block: Block_height): [TokenDayData!]!
}

type Swap {
  id: ID!
  pair: Pair!
  sender: String!
  from: String!
  to: String!
  amount0In: BigDecimal!
  amount1In: BigDecimal!
  amount0Out: BigDecimal!
  amount1Out: BigDecimal!
  amountUSD: BigDecimal!
  token0: Token!
  token1: Token!
  logIndex: BigInt
  transaction: Transaction!
  timestamp: BigInt!
}

input Swap_filter {
  pair: ID
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  token0: String
  token1: String
}

enum Swap_orderBy {
  timestamp
}

type Token {
  id: ID!
  name: String!
  symbol: String!
  decimals: BigInt!
  totalTransactions: BigInt!
  tradeVolume: BigDecimal!
  tradeVolumeUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  totalLiquidity: BigDecimal!
  derivedBNB: BigDecimal
  derivedUSD: BigDecimal
}

input Token_filter {
  id_in: [ID!]
  symbol_contains: String
  name_contains: String
  id: ID
}

enum Token_orderBy {
  tradeVolumeUSD
}

type TokenDayData {
  id: ID!
  date: Int!
  token: Token!
  dailyVolumeToken: BigDecimal!
  dailyVolumeBNB: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyTxns: BigInt!
  totalLiquidityToken: BigDecimal!
  totalLiquidityBNB: BigDecimal!
  totalLiquidityUSD: BigDecimal!
  priceUSD: BigDecimal!
}

input TokenDayData_filter {
  dailyTxns_gt: BigInt
  id_not_in: [ID!]
  date_gt: Int
  date_lt: Int
  date: Int
  token: String
}

enum TokenDayData_orderBy {
  dailyVolumeUSD
  date
}

type Transaction {
  id: ID!
  block: BigInt!
  timestamp: BigInt!
  mints: [Mint]!
  burns: [Burn]!
  swaps: [Swap]!
}
